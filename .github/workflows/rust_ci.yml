name: Rust CI & Cross-Platform Release

on:
  push:
    branches: [ "main" ]
    # 新增：只有當推送標籤為 vX.Y.Z 格式時才觸發 CI/CD 流程
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  pull_request:
    branches: [ "main" ]

env:
  CARGO_TERM_COLOR: always # 讓 Cargo 輸出帶有顏色
  BIN_NAME: hls-downloader # 定義專案二進制名稱，以匹配 Cargo.toml 中 [[bin]] 的設置

jobs:
  # ----------------------------------------------------
  # 1. Check & Test Job: 執行程式碼品質檢查和測試
  # ----------------------------------------------------
  check:
    name: Check & Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          components: rustfmt

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Run cargo fmt check
        uses: actions-rs/cargo@v1
        with:
          command: fmt
          args: --check

      - name: Run cargo check
        uses: actions-rs/cargo@v1
        with:
          command: check

      - name: Run cargo test
        uses: actions-rs/cargo@v1
        with:
          command: test

  # ----------------------------------------------------
  # 2. Build Artifacts Job: 建構跨平台 Release 二進制檔案
  # ----------------------------------------------------
  build_artifacts:
    name: Build ${{ matrix.os }} Release
    needs: check
    # 僅在推送標籤時執行
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            target_dir: target/x86_64-unknown-linux-gnu/release
            asset_ext: tar.gz
            asset_name: linux-x64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            target_dir: target/x86_64-pc-windows-msvc/release
            asset_ext: zip
            asset_name: windows-x64
          - os: macos-latest
            target: x86_64-apple-darwin
            target_dir: target/x86_64-apple-darwin/release
            asset_ext: tar.gz
            asset_name: macos-x64

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.target }}
          profile: minimal
          override: true

      # 安裝 Linux 執行所需的依賴 (eframe/egui 通常需要的 GTK/XCB 庫)
      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y libxcb-render0-dev libxcb-shape0-dev libxcb-xfixes0-dev libgtk-3-dev libssl-dev

      - name: Build release binary
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release --target ${{ matrix.target }}

      # 設置二進制檔案的完整路徑和名稱
      - name: Set Binary Path and Name
        id: set_path
        run: |
          BINARY_PATH="${{ matrix.target_dir }}/${{ env.BIN_NAME }}"
          # Windows 的執行檔名稱會有 .exe 後綴
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            BINARY_PATH="${{ matrix.target_dir }}/${{ env.BIN_NAME }}.exe"
          fi
          echo "BIN_PATH=${BINARY_PATH}" >> $GITHUB_OUTPUT
          echo "ARCHIVE_NAME=${{ env.BIN_NAME }}-${{ matrix.asset_name }}.${{ matrix.asset_ext }}" >> $GITHUB_OUTPUT

      # 壓縮二進制檔案 (Linux & macOS: tar.gz)
      - name: Compress Linux/macOS
        if: runner.os != 'Windows'
        run: tar -czf ${{ steps.set_path.outputs.ARCHIVE_NAME }} -C ${{ matrix.target_dir }} ${{ env.BIN_NAME }}

      # 壓縮二進制檔案 (Windows: zip)
      - name: Compress Windows
        if: runner.os == 'Windows'
        # 使用 PowerShell 的 Compress-Archive Cmdlet，使用 step 輸出的 BIN_PATH
        run: Compress-Archive -Path ${{ steps.set_path.outputs.BIN_PATH }} -DestinationPath ${{ steps.set_path.outputs.ARCHIVE_NAME }}

      # 上傳壓縮後的檔案作為 Artifact
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          # 將 Artifact 名稱定義為最終檔案名
          name: ${{ steps.set_path.outputs.ARCHIVE_NAME }}
          path: ${{ steps.set_path.outputs.ARCHIVE_NAME }}
          retention-days: 1 # Artifacts 只需要短暫保留

  # ----------------------------------------------------
  # 3. Create GitHub Release Job: 下載所有 Artifacts 並發布
  # ----------------------------------------------------
  create_github_release:
    name: Create GitHub Release
    needs: build_artifacts
    runs-on: ubuntu-latest
    permissions:
      contents: write # 必須要有寫入權限才能創建 Release
    # 確保只有在標籤推送時才執行
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      # 為了確保發佈的 Assets 檔案存在於本地，我們需要先下載
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          # 不指定 name 會下載所有 artifacts，它們會被放在以 artifact 名稱命名的子目錄中
          path: release_assets

      # 建立 Release Notes (從 Git Tag 訊息或其他地方獲取)
      - name: Generate Release Notes
        run: echo "## What's Changed in ${{ github.ref_name }}\n\n- Initial release or features." > release_notes.md

      # 使用 softprops/action-gh-release 創建 Release
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          # github.ref_name 是 vX.Y.Z 標籤名稱
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body_path: release_notes.md
          draft: false # 設為 true 可以先作為草稿
          prerelease: false

          # 將所有下載的 Artifacts (在 release_assets/ 子目錄中) 作為 Assets 附加
          # 使用 artifact 的名稱作為檔案名，所以 glob 模式為 */*
          files: release_assets/*/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
